# Dynamic programming
- Recursion without repetition
- Each sub problem must be evaluated only once
- Naive recursion approach takes exponential time due to repetition 
# Top down with memoisation
- This is depth first search implementation of recursion
- Cache repetitive work
# Bottom up
- Is based on dependency graph
- Convert recursion into dependency graph
- It is directed acyclic graph
- You can sort DAG using topological sort
- One way to avoid repetition is to calculate as per topological sort order
- This is solving based on increasing sub problem
- Write iterative code
# Optimal Substructure property
# Problems
https://leetcode.com/problems/fibonacci-number/
https://leetcode.com/problems/climbing-stairs/
https://leetcode.com/problems/subsets/
https://leetcode.com/problems/subsets-ii/
https://leetcode.com/problems/edit-distance/
https://leetcode.com/problems/knight-dialer/
https://leetcode.com/problems/house-robber/
https://leetcode.com/problems/house-robber-ii/
https://leetcode.com/problems/house-robber-iii/
https://leetcode.com/problems/partition-equal-subset-sum/
https://leetcode.com/problems/word-break/
https://leetcode.com/problems/word-break-ii/
https://leetcode.com/problems/coin-change/
https://leetcode.com/problems/coin-change-2/

# Matrix related problems
https://leetcode.com/problems/maximal-square/
https://leetcode.com/problems/maximal-rectangle/
https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/
https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/


# String related problems
https://leetcode.com/problems/wildcard-matching/


